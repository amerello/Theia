

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Structure from Motion (SfM) &mdash; Theia Vision Library</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="Theia Vision Library" href="index.html"/>
        <link rel="next" title="Tutorials" href="tutorials.html"/>
        <link rel="prev" title="Math" href="math.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="index.html" class="fa fa-home"> Theia Vision Library</a>
        
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building.html">Building Theia Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="building.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#building">Building</a></li>
<li class="toctree-l2"><a class="reference internal" href="building.html#customizing-the-build">Customizing the build</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="image.html">Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="features.html#keypoints">Keypoints</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#keypoint-detector">Keypoint Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#descriptors">Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html#descriptorextractor">DescriptorExtractor</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="features.html#feature-matching">Feature Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="ransac.html">Ransac</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ransac.html#estimator"><tt class="docutils literal"><span class="pre">Estimator</span></tt></a></li>
<li class="toctree-l2"><a class="reference internal" href="ransac.html#using-the-ransac-classes">Using the RANSAC classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ransac.html#instances-of-ransac-methods">Instances of RANSAC Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="ransac.html#implementing-a-new-ransac-method">Implementing a New RANSAC Method</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pose.html">Pose and Resectioning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pose.html#perspective-three-point-p3p">Perspective Three Point (P3P)</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#five-point-relative-pose">Five Point Relative Pose</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-algorithm-for-homography">Four Point Algorithm for Homography</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#eight-point-algorithm-for-fundamental-matrix">Eight Point Algorithm for Fundamental Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#perspective-n-point">Perspective N-Point</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-focal-length">Four Point Focal Length</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#five-point-focal-length-and-radial-distortion">Five Point Focal Length and Radial Distortion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#three-point-relative-pose-with-a-partially-known-rotation">Three Point Relative Pose with a Partially Known Rotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html#four-point-relative-pose-with-a-partially-known-rotation">Four Point Relative Pose with a Partially Known Rotation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="math.html">Math</a><ul>
<li class="toctree-l2"><a class="reference internal" href="math.html#closed-form-polynomial-solver">Closed Form Polynomial Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#generic-polynomial-solver">Generic Polynomial Solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#guass-jordan">Guass-Jordan</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html#sequential-probability-ratio-test">Sequential Probability Ratio Test</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Structure from Motion (SfM)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#views-and-tracks">Views and Tracks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#viewgraph">ViewGraph</a></li>
<li class="toctree-l2"><a class="reference internal" href="#camera">Camera</a></li>
<li class="toctree-l2"><a class="reference internal" href="#model">Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#estimating-global-poses">Estimating Global Poses</a></li>
<li class="toctree-l2"><a class="reference internal" href="#triangulation">Triangulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bundle-adjustment">Bundle Adjustment</a></li>
<li class="toctree-l2"><a class="reference internal" href="#similarity-transformation">Similarity Transformation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributions.html">Contributing to Theia</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#style-and-testing">Style and Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#cmake">CMake</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#developing-for-theia">Developing for Theia</a></li>
<li class="toctree-l2"><a class="reference internal" href="contributions.html#submitting-a-change-to-theia">Submitting a change to Theia</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="license.html#citation">Citation</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Theia Vision Library</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Structure from Motion (SfM)</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="structure-from-motion-sfm">
<span id="documentation-sfm"></span><h1>Structure from Motion (SfM)<a class="headerlink" href="#structure-from-motion-sfm" title="Permalink to this headline">¶</a></h1>
<p>Theia has a full Structure-from-Motion pipeline that is extremely efficient. Our
overall pipeline consists of several steps. First, we extract features (SIFT is
the default). Then, we perform two-view matching and geometric verification to
obtain relative poses between image pairs and create a <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>. Next,
we perform global pose estimation with &#8220;one-shot&#8221; SfM (also called Global
SfM).. One-shot SfM is different from incremental SfM in that it considers the
entire view graph at the same time instead of successfully adding more and more
images to the <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a>. One-shot SfM methods have been proven to be very
fast with comparable or better accuracy to incremental SfM approaches (See
<a class="reference internal" href="bibliography.html#jiangiccv" id="id1">[JiangICCV]</a>, <a class="reference internal" href="bibliography.html#mouloniccv" id="id2">[MoulonICCV]</a>, <a class="reference internal" href="bibliography.html#wilsoneccv" id="id3">[WilsonECCV]</a>), and they are much more easily
parallelized. After we have obtained camera poses, we perform triangulation and
<tt class="xref cpp cpp-class docutils literal"><span class="pre">BundleAdjustment</span></tt> to obtain a valid 3D reconstruction consisting of
cameras and 3D points.</p>
<p>Extracting and matching <a class="reference internal" href="features.html#documentation-features"><em>Features</em></a> has been covered already, so we
will now discuss how to go from feature matches to a <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>. First,
however, we must present the basic building blocks for our SfM pipeline.</p>
<p>Additionally, while this documentation is a useful overview of the SfM pipeline
we provide, there are many other useful methods that are not documented here
that can be found in the <tt class="docutils literal"><span class="pre">theia/vision/sfm/</span></tt> directory. All header and source
files in Theia include extensive documentation.</p>
<div class="section" id="views-and-tracks">
<h2>Views and Tracks<a class="headerlink" href="#views-and-tracks" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="View">
<em class="property">class </em><tt class="descname">View</tt><a class="headerlink" href="#View" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>At the heart of our SfM framework is the <a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a> class which represents
everything about an image that we want to reconstruct. It contains information
about features from the image, camera pose information, and metadata information
(including the image name and EXIF data). Views make up our basic visiblity
constraints and are a fundamental part of the SfM pipeline.</p>
<dl class="class">
<dt id="Track">
<em class="property">class </em><tt class="descname">Track</tt><a class="headerlink" href="#Track" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A <a class="reference internal" href="#Track" title="Track"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Track</span></tt></a> represents a feature that has been matached over potentially
many images. When a feature appears in multiple images it typically means that
the features correspond to the same 3D point. These 3D points are useful
constraints in SfM model, as they represent the &#8220;structure&#8221; in
&#8220;Structure-from-Motion&#8221; and help to build a point cloud for our model.</p>
</div>
<div class="section" id="viewgraph">
<h2>ViewGraph<a class="headerlink" href="#viewgraph" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ViewGraph">
<em class="property">class </em><tt class="descname">ViewGraph</tt><a class="headerlink" href="#ViewGraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a> is a basic SfM construct that is created from two-view
matching information. Any pair of views that have a view correlation form an
edge in the <a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a> such that the nodes in the graph are
<a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a> that are connected by <tt class="xref cpp cpp-class docutils literal"><span class="pre">TwoViewInfo</span></tt> objects that contain
information about the relative pose between the Views as well as matching
information.</p>
<p>Once you have a set of views and match information, you can add them to the view graph:</p>
<div class="code c++ highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;</span> <span class="n">views</span><span class="p">;</span>
<span class="c1">// Match all views in the set.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ViewIdPair</span><span class="p">,</span> <span class="n">TwoViewInfo</span><span class="o">&gt;</span> <span class="n">view_pair_matches</span><span class="p">;</span>

<span class="n">ViewGraph</span> <span class="n">view_graph</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">view_pair</span> <span class="o">:</span> <span class="n">view_pair_matches</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">ViewIdPair</span><span class="o">&amp;</span> <span class="n">view_id_pair</span> <span class="o">=</span> <span class="n">view_pair</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">TwoViewInfo</span><span class="o">&amp;</span> <span class="n">two_view_info</span> <span class="o">=</span> <span class="n">view_pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="c1">// Only add view pairs to the view graph if they have strong visual coherence.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">two_view_info</span><span class="p">.</span><span class="n">num_matched_features</span> <span class="o">&gt;</span> <span class="n">min_num_matched_features</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">view_graph</span><span class="p">.</span><span class="n">AddEdge</span><span class="p">(</span><span class="n">views</span><span class="p">[</span><span class="n">view_id_pair</span><span class="p">.</span><span class="n">first</span><span class="p">],</span>
                       <span class="n">views</span><span class="p">[</span><span class="n">view_id_pair</span><span class="p">.</span><span class="n">second</span><span class="p">],</span>
                       <span class="n">two_view_info</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Process and/or manipulate the view graph.</span>
</pre></div>
</div>
<p>The edge values are especially useful for one-shot SfM where the relative poses
are heavily exploited for computing the final poses. Without a proper
<a class="reference internal" href="#ViewGraph" title="ViewGraph"><tt class="xref cpp cpp-class docutils literal"><span class="pre">ViewGraph</span></tt></a>, one-shot SfM would not be possible.</p>
</div>
<div class="section" id="camera">
<h2>Camera<a class="headerlink" href="#camera" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Camera">
<em class="property">class </em><tt class="descname">Camera</tt><a class="headerlink" href="#Camera" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Each <a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a> contains a <a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> object that contains intrinsic and
extrinsic information about the camera that observed the scene. Theia has an
efficient, compact <a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> class that abstracts away common image
operations. This greatly relieves the pain of manually dealing with calibration
and geometric transformations of images. We represent camera intrinsics such
that the calibration matrix is:</p>
<div class="math">
\[\begin{split}K = \left[\begin{matrix}f &amp; s &amp; p_x \\ 0 &amp; f * a &amp; p_y \\ 0 &amp; 0 &amp; 1 \end{matrix} \right]\end{split}\]</div>
<p>where <span class="math">\(f\)</span> is the focal length (in pixels), <span class="math">\(s\)</span> is the skew,
<span class="math">\(a\)</span> is the aspect ratio and <span class="math">\(p\)</span> is the principle point of the
camera. All of these intrinsics may be accessed with getter and setter methods,
e.g., <tt class="code docutils literal"><span class="pre">double</span> <span class="pre">GetFocalLenth()</span></tt> or <tt class="code docutils literal"><span class="pre">void</span> <span class="pre">SetFocalLength(const</span> <span class="pre">double</span>
<span class="pre">focal_length)</span></tt>. Note that we do additionally allow for up to two radial
distortion parameters, but these are not part of the calibration matrix so they
must be set or retrieved separately from the corresponding getter/setter
methods.</p>
<p>We store the camera pose information as the transformation which maps world
coordinates into camera coordinates. Our rotation is stored internally as an
<cite>SO(3)</cite> rotation, which makes optimization with <tt class="xref cpp cpp-class docutils literal"><span class="pre">BundleAdjustment</span></tt> more
effective since the value is always a valid rotation (unlike e.g., Quaternions
that must be normalized after each optimization step). However, for convenience
we provide an interface to retrieve the rotation as a rotation matrix as
well. Further, we store the camera position as opposed to the translation.</p>
<p>The convenience of this camera class is clear with the common example of 3D
point reprojection.</p>
<div class="code c++ highlight-c++"><div class="highlight"><pre><span class="c1">// Open an image and obtain camera parameters.</span>
<span class="n">FloatImage</span> <span class="nf">image</span><span class="p">(</span><span class="s">&quot;my_image.jpg&quot;</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">focal_length</span><span class="p">;</span>
<span class="n">CHECK</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">FocalLengthPixels</span><span class="p">(</span><span class="o">&amp;</span><span class="n">focal_length</span><span class="p">));</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">radial_distortion1</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">radial_distortion2</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">position</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>

<span class="c1">// Set up the camera.</span>
<span class="n">Camera</span> <span class="n">camera</span><span class="p">;</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetOrientationFromRotationMatrix</span><span class="p">(</span><span class="n">rotation</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetPosition</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetFocalLength</span><span class="p">(</span><span class="n">focal_length</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetPrincipalPoint</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">Width</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">Height</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="n">camera</span><span class="p">.</span><span class="n">SetRadialDistortion</span><span class="p">(</span><span class="n">radial_distortion1</span><span class="p">,</span> <span class="n">radial_distortion2</span><span class="p">);</span>

<span class="c1">// Obtain a homogeneous 3D point</span>
<span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span> <span class="n">homogeneous_point3d</span> <span class="o">=</span> <span class="n">value</span> <span class="n">obtained</span> <span class="n">elsewhere</span><span class="p">...</span>

<span class="c1">// Reproject the 3D point to a pixel.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span> <span class="n">reprojection_pixel</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">ProjectPoint</span><span class="p">(</span><span class="n">homogeneous_point3d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pixel</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Point was behind the camera!&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Homogeneous 3D point: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">homogeneous_point3d</span>
          <span class="o">&lt;&lt;</span> <span class="s">&quot; reprojected to the pixel value of &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">reprojection_pixel</span><span class="p">;</span>
</pre></div>
</div>
<p>Point projection can be a tricky function when considering the camera intrinsics
and extrinsics. Theia takes care of this projection (including radial
distortion) in a simple and efficient manner.</p>
<p>In addition to typical getter/setter methods for the camera parameters, the
<a class="reference internal" href="#Camera" title="Camera"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt></a> class also defines several helper functions:.</p>
<dl class="function">
<dt id="InitializeFromProjectionMatrix__iC.iC.Matrix3x4dC">
bool <tt class="descname">InitializeFromProjectionMatrix</tt><big>(</big>const int <em>image_width</em>, const int <em>image_height</em>, const Matrix3x4d <em>projection_matrix</em><big>)</big><a class="headerlink" href="#InitializeFromProjectionMatrix__iC.iC.Matrix3x4dC" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the camera intrinsic and extrinsic parameters from the
projection matrix by decomposing the matrix with a RQ decomposition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The projection matrix does not contain information about radial
distortion, so those parameters will need to be set separately.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="GetProjectionMatrix__Matrix3x4dPC">
void <tt class="descname">GetProjectionMatrix</tt><big>(</big>Matrix3x4d* <em>pmatrix</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#GetProjectionMatrix__Matrix3x4dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the projection matrix. Does not include radial distortion.</p>
</dd></dl>

<dl class="function">
<dt id="GetCalibrationMatrix__Eigen::Matrix3dPC">
void <tt class="descname">GetCalibrationMatrix</tt><big>(</big>Eigen::Matrix3d* <em>kmatrix</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#GetCalibrationMatrix__Eigen::Matrix3dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the calibration matrix in the form specified above.</p>
</dd></dl>

<dl class="function">
<dt id="PixelToUnitDepthRay__Eigen::Vector2dCRC">
Eigen::Vector3d <tt class="descname">PixelToUnitDepthRay</tt><big>(</big>const Eigen::Vector2d&amp; <em>pixel</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#PixelToUnitDepthRay__Eigen::Vector2dCRC" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the pixel point to a ray in 3D space such that the origin of the
ray is at the camera center and the direction is the pixel direction rotated
according to the camera orientation in 3D space. The returned vector is not
unit length.</p>
</dd></dl>

</div>
<div class="section" id="model">
<h2>Model<a class="headerlink" href="#model" title="Permalink to this headline">¶</a></h2>
<p>At the core of our SfM pipeline is an SfM <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a>. A <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a> is
the representation of a 3D reconstuction consisting of a set of unique Views and
Tracks. More importantly, the <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a> class contains visibility
information relating all of the Views and Tracks to each other. We identify each
<a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a> uniquely based on the name (a string). A good name for the view is
the filename of the image that corresponds to the <a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a></p>
<p>When creating an SfM reconstruction, you should add each <a class="reference internal" href="#View" title="View"><tt class="xref cpp cpp-class docutils literal"><span class="pre">View</span></tt></a> and
<a class="reference internal" href="#Track" title="Track"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Track</span></tt></a> through the <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a> object. This will ensure that
visibility information (such as which Tracks are observed a given View and which
Views see a given Track) stays accurate. Views and Tracks are given a unique ID
when added to the <a class="reference internal" href="#Model" title="Model"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Model</span></tt></a> to help make use of these structures
lightweight and efficient.</p>
<dl class="class">
<dt id="Model">
<em class="property">class </em><tt class="descname">Model</tt><a class="headerlink" href="#Model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="AddTrack__std::vector:std::pair:ss.Feature::CR">
TrackId <tt class="descname">AddTrack</tt><big>(</big>const std::vector&lt;std::pair&lt;std::string, Feature&gt;&gt;&amp; <em>track</em><big>)</big><a class="headerlink" href="#AddTrack__std::vector:std::pair:ss.Feature::CR" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a track to the model with all of its features across views that observe
this track. Each pair contains a feature and the corresponding View name
(i.e., the string) that observes the feature. A new View will be created if
a View with the view name does not already exist. This method will not
estimate the position of the track. The TrackId returned will be unique or
will be kInvalidTrackId if the method fails.</p>
</dd></dl>

<dl class="function">
<dt id="RemoveTrack__TrackIdC">
bool <tt class="descname">RemoveTrack</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><a class="headerlink" href="#RemoveTrack__TrackIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the track from the model and from any Views that observe this
track. Returns true on success and false on failure (e.g., the track does
not exist).</p>
</dd></dl>

<dl class="function">
<dt id="Track__TrackIdCC">
const Track* <tt class="descname">Track</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Track__TrackIdCC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MutableTrack__TrackIdC">
Track* <tt class="descname">MutableTrack</tt><big>(</big>const TrackId <em>track_id</em><big>)</big><a class="headerlink" href="#MutableTrack__TrackIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Track or a nullptr if the track does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="TrackIdsC">
std::vector&lt;TrackId&gt; <tt class="descname">TrackIds</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#TrackIdsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all TrackIds in the model.</p>
</dd></dl>

<dl class="function">
<dt id="AddView__ssCR">
ViewId <tt class="descname">AddView</tt><big>(</big>const std::string&amp; <em>view_name</em><big>)</big><a class="headerlink" href="#AddView__ssCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a view to the model with the default initialization. The ViewId
returned is guaranteed to be unique or will be kInvalidViewId if the method
fails (e.g., if a view with that name already exists)</p>
</dd></dl>

<dl class="function">
<dt id="RemoveView__ViewIdC">
bool <tt class="descname">RemoveView</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><a class="headerlink" href="#RemoveView__ViewIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the view from the model and removes all references to the view in
the tracks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is possible to have tracks of length 0 after this method is executed.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="NumViewsC">
int <tt class="descname">NumViews</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#NumViewsC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="NumTracksC">
int <tt class="descname">NumTracks</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#NumTracksC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="View__ViewIdCC">
const View* <tt class="descname">View</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#View__ViewIdCC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="MutableView__ViewIdC">
View* <tt class="descname">MutableView</tt><big>(</big>const ViewId <em>view_id</em><big>)</big><a class="headerlink" href="#MutableView__ViewIdC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the View or a nullptr if the track does not exist.</p>
</dd></dl>

<dl class="function">
<dt id="ViewIdsC">
std::vector&lt;ViewId&gt; <tt class="descname">ViewIds</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ViewIdsC" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all ViewIds in the model.</p>
</dd></dl>

<dl class="function">
<dt id="ViewIdFromName__ssCRC">
ViewId <tt class="descname">ViewIdFromName</tt><big>(</big>const std::string&amp; <em>view_name</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#ViewIdFromName__ssCRC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns to ViewId of the view name, or kInvalidViewId if the view does not
exist.</p>
</dd></dl>

</div>
<div class="section" id="estimating-global-poses">
<h2>Estimating Global Poses<a class="headerlink" href="#estimating-global-poses" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Documentation coming soon..</p>
</div>
</div>
<div class="section" id="triangulation">
<h2>Triangulation<a class="headerlink" href="#triangulation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Triangulation in structure from motion calculates the 3D position of an image
coordinate that has been tracked through several, if not many, images.</p>
<dl class="function">
<dt id="Triangulate__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP">
bool <tt class="descname">Triangulate</tt><big>(</big>const Matrix3x4d&amp; <em>pose1</em>, const Matrix3x4d&amp; <em>pose2</em>, const Eigen::Vector2d&amp; <em>point1</em>, const Eigen::Vector2d&amp; <em>point2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#Triangulate__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>2-view triangulation using the method described in <a class="reference internal" href="bibliography.html#lindstrom" id="id4">[Lindstrom]</a>. This method
is optimal in an L2 sense such that the reprojection errors are minimized
while enforcing the epipolar constraint between the two
cameras. Additionally, it basically the same speed as the
<a class="reference internal" href="#TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="TriangulateDLT"><tt class="xref cpp cpp-func docutils literal"><span class="pre">TriangulateDLT()</span></tt></a> method.</p>
<p>The poses are the (potentially calibrated) poses of the two cameras, and the
points are the 2D image points of the matched features that will be used to
triangulate the 3D point. On successful triangulation, <tt class="docutils literal"><span class="pre">true</span></tt> is
returned. The homogeneous 3d point is output so that it may be known if the
point is at infinity.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP">
bool <tt class="descname">TriangulateDLT</tt><big>(</big>const Matrix3x4d&amp; <em>pose1</em>, const Matrix3x4d&amp; <em>pose2</em>, const Eigen::Vector2d&amp; <em>point1</em>, const Eigen::Vector2d&amp; <em>point2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateDLT__Matrix3x4dCR.Matrix3x4dCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>The DLT triangulation method of <a class="reference internal" href="bibliography.html#hartleyzisserman" id="id5">[HartleyZisserman]</a>.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateMidpoint__Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector4dP">
bool <tt class="descname">TriangulateMidpoint</tt><big>(</big>const Eigen::Vector3d&amp; <em>origin1</em>, const Eigen::Vector3d&amp; <em>ray_direction1</em>, const Eigen::Vector3d&amp; <em>origin2</em>, const Eigen::Vector3d&amp; <em>ray_direction2</em>, Eigen::Vector4d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateMidpoint__Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector3dCR.Eigen::Vector4dP" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform triangulation by determining the closest point between the two
rays. In this case, the ray origins are the camera positions and the
directions are the (unit-norm) ray directions of the features in 3D
space. This method is known to be suboptimal at minimizing the reprojection
error, but is approximately 10x faster than the other 2-view triangulation
methods.</p>
</dd></dl>

<dl class="function">
<dt id="TriangulateNViewSVD__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNViewSVD</tt><big>(</big>const std::vector&lt;Matrix3x4d&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNViewSVD__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TriangulateNView__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNView</tt><big>(</big>const std::vector&lt;Matrix3x4d&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNView__std::vector:Matrix3x4d:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd><p>We provide two N-view triangluation methods that minimizes an algebraic
approximation of the geometric error. The first is the classic SVD method
presented in <a class="reference internal" href="bibliography.html#hartleyzisserman" id="id6">[HartleyZisserman]</a>. The second is a custom algebraic
minimization. Note that we can derive an algebraic constraint where we note
that the unit ray of an image observation can be stretched by depth
<span class="math">\(\alpha\)</span> to meet the world point <span class="math">\(X\)</span> for each of the <span class="math">\(n\)</span>
observations:</p>
<div class="math">
\[\alpha_i \bar{x_i} = P_i X,\]</div>
<p>for images <span class="math">\(i=1,\ldots,n\)</span>. This equation can be effectively rewritten as:</p>
<div class="math">
\[\alpha_i = \bar{x_i}^\top P_i X,\]</div>
<p>which can be substituted into our original constraint such that:</p>
<div class="math">
\[\bar{x_i} \bar{x_i}^\top P_i X = P_i X\]</div>
<div class="math">
\[0 = (P_i - \bar{x_i} \bar{x_i}^\top P_i) X\]</div>
<p>We can then stack this constraint for each observation, leading to the linear
least squares problem:</p>
<div class="math">
\[\begin{split}\begin{bmatrix} (P_1 - \bar{x_1} \bar{x_1}^\top P_1) \\ \vdots \\ (P_n - \bar{x_n} \bar{x_n}^\top P_n) \end{bmatrix} X = \textbf{0}\end{split}\]</div>
<p>This system of equations is of the form <span class="math">\(AX=0\)</span> which can be solved by
extracting the right nullspace of <span class="math">\(A\)</span>. The right nullspace of <span class="math">\(A\)</span>
can be extracted efficiently by noting that it is equivalent to the nullspace
of <span class="math">\(A^\top A\)</span>, which is a 4x4 matrix.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="bundle-adjustment">
<h2>Bundle Adjustment<a class="headerlink" href="#bundle-adjustment" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Docmentation coming soon...</p>
</div>
</div>
<div class="section" id="similarity-transformation">
<h2>Similarity Transformation<a class="headerlink" href="#similarity-transformation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA">
void <tt class="descname">AlignPointCloudsICP</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3]<big>)</big><a class="headerlink" href="#AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA" title="Permalink to this definition">¶</a></dt>
<dd><p>We implement ICP for point clouds. We use Besl-McKay registration to align
point clouds. We use SVD decomposition to find the rotation, as this is much
more likely to find the global minimum as compared to traditional ICP, which
is only guaranteed to find a local minimum. Our goal is to find the
transformation from the left to the right coordinate system. We assume that
the left and right models have the same number of points, and that the
points are aligned by correspondence (i.e. left[i] corresponds to right[i]).</p>
</dd></dl>

<dl class="function">
<dt id="AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP">
void <tt class="descname">AlignPointCloudsUmeyama</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3], double* <em>scale</em><big>)</big><a class="headerlink" href="#AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>This function estimates the 3D similiarty transformation using the least
squares method of <a class="reference internal" href="bibliography.html#umeyama" id="id7">[Umeyama]</a>. The returned rotation, translation, and scale
align the left points to the right such that <span class="math">\(Right = s * R * Left +
t\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="GdlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P">
void <tt class="descname">GdlsSimilarityTransform</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_origin</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_direction</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>world_point</em>, std::vector&lt;Eigen::Quaterniond&gt;* <em>solution_rotation</em>, std::vector&lt;Eigen::Vector3d&gt;* <em>solution_translation</em>, std::vector&lt;double&gt;* <em>solution_scale</em><big>)</big><a class="headerlink" href="#GdlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution to the generalized pose and scale problem based on the
paper &#8220;gDLS: A Scalable Solution to the Generalized Pose and Scale Problem&#8221;
by Sweeney et. al. <a class="reference internal" href="bibliography.html#sweeneygdls" id="id8">[SweeneyGDLS]</a>. Given image rays from one coordinate
system that correspond to 3D points in another coordinate system, this
function computes the rotation, translation, and scale that will align the
rays with the 3D points. This is used for applications such as loop closure
in SLAM and SfM. This method is extremely scalable and highly accurate
because the cost function that is minimized is independent of the number of
points. Theoretically, up to 27 solutions may be returned, but in practice
only 4 real solutions arise and in almost all cases where n &gt;= 6 there is
only one solution which places the observed points in front of the
camera. The rotation, translation, and scale are defined such that:
<span class="math">\(sp_i + \alpha_i d_i = RX_i + t\)</span> where the observed image ray has an
origin at <span class="math">\(p_i\)</span> in the unit direction <span class="math">\(d_i\)</span> corresponding to 3D
point <span class="math">\(X_i\)</span>.</p>
<p><tt class="docutils literal"><span class="pre">ray_origin</span></tt>: the origin (i.e., camera center) of the image ray used in
the 2D-3D correspondence.</p>
<p><tt class="docutils literal"><span class="pre">ray_direction</span></tt>: Normalized image rays corresponding to model points. Must
contain at least 4 points.</p>
<p><tt class="docutils literal"><span class="pre">world_point</span></tt>: 3D location of features. Must correspond to the image_ray
of the same index. Must contain the same number of points as image_ray, and
at least 4.</p>
<p><tt class="docutils literal"><span class="pre">solution_rotation</span></tt>: the rotation quaternion of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_translation</span></tt>: the translation of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_scale</span></tt>: the scale of the candidate solutions</p>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tutorials.html" class="btn btn-neutral float-right" title="Tutorials">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="math.html" class="btn btn-neutral" title="Math"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Chris Sweeney.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<!-- Google Analytics Code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46196711-1', 'ucsb.edu');
  ga('send', 'pageview');

</script>


</body>
</html>