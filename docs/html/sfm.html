
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    

    <title>Structure from Motion (SfM) &mdash; Theia Documentation</title>

<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>

<!-- Google Analytics Code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46196711-1', 'ucsb.edu');
  ga('send', 'pageview');

</script>


    
    <link rel="stylesheet" href="_static/rtd.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>
    <script type="text/javascript" src="_static/searchtools.js"></script>
    <link rel="top" title="Theia Documentation" href="index.html" />
    <link rel="up" title="Documentation" href="documentation.html" />
    <link rel="next" title="Tutorials" href="tutorials.html" />
    <link rel="prev" title="Math" href="math.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="math.html" title="Math"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Theia Documentation</a> &raquo;</li>
          <li><a href="documentation.html" accesskey="U">Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="structure-from-motion-sfm">
<span id="documentation-sfm"></span><h1>Structure from Motion (SfM)<a class="headerlink" href="#structure-from-motion-sfm" title="Permalink to this headline">¶</a></h1>
<p>Theia has implementations of many common Structure from Motion (sfm) algorithms. We
attempt to use a generic interface whenever possible so as to maximize
compatibility with other libraries.</p>
<p>You can include the SfM module in your code with the following line:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;theia/sfm.h&gt;</span>
</pre></div>
</div>
<div class="section" id="projection-matrix">
<h2>Projection Matrix<a class="headerlink" href="#projection-matrix" title="Permalink to this headline">¶</a></h2>
<p>We provide two convenience matrices that are commonly used in multiview geometry. The first is a <tt class="xref cpp cpp-class docutils literal"><span class="pre">TransformationMatrix</span></tt> which is an affine transformation matrix composed of rotation and translation of the form: <span class="math">\(\left[R | t\right]\)</span>, i.e., the extrinsic parameters of a camera. The <tt class="xref cpp cpp-class docutils literal"><span class="pre">TransformationMatrix</span></tt> is merely a typedef of the Eigen affine transformation matrix. Similarly, a <tt class="xref cpp cpp-class docutils literal"><span class="pre">ProjectionMatrix</span></tt> class is defined that representsthe intrinsic and extrinsic parameters, nameley matrices of the form: <span class="math">\(K\left[R | t \right]\)</span> where <span class="math">\(K\)</span> is a 3x3 matrix of the camera intrinsics (e.g., focal length, principle point, and radial distortion). The <tt class="xref cpp cpp-class docutils literal"><span class="pre">ProjectionMatrix</span></tt> is merely a typedef of an Eigen 3x4 matrix.</p>
</div>
<div class="section" id="camera-and-camerapose">
<h2>Camera and CameraPose<a class="headerlink" href="#camera-and-camerapose" title="Permalink to this headline">¶</a></h2>
<p>At the core of SfM are cameras which provide us with observations of 3D points. Theia uses a <tt class="xref cpp cpp-class docutils literal"><span class="pre">Camera</span></tt> struct to maintain all imaging and view information. This includes information about the image captured, the feature positions (both in the image planes and in 3D space), and feature descriptors.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Camera</span> <span class="p">{</span>
  <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>
  <span class="n">Camera</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">explicit</span> <span class="n">Camera</span><span class="p">(</span><span class="k">const</span> <span class="n">CameraPose</span><span class="o">&amp;</span> <span class="n">pose</span><span class="p">)</span> <span class="o">:</span> <span class="n">pose_</span><span class="p">(</span><span class="n">pose</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// The camera pose describing the position, orientation, and intrinsics of the</span>
  <span class="c1">// camera.</span>
  <span class="n">CameraPose</span> <span class="n">pose_</span><span class="p">;</span>

  <span class="c1">// Width of the camera in pixels.</span>
  <span class="kt">int</span> <span class="n">width_</span><span class="p">;</span>
  <span class="c1">// Height of the camera in pixels.</span>
  <span class="kt">int</span> <span class="n">height_</span><span class="p">;</span>

  <span class="c1">// Original measured feature positions.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&gt;</span> <span class="n">feature_position_2D_distorted_</span><span class="p">;</span>
  <span class="c1">// Feature positions after correcting for radial distortion.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&gt;</span> <span class="n">feature_position_2D_</span><span class="p">;</span>

  <span class="c1">// Descriptors.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span><span class="o">&gt;</span> <span class="n">descriptors_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">BinaryVectorX</span><span class="o">&gt;</span> <span class="n">binary_descriptors_</span><span class="p">;</span>

  <span class="c1">// 3D feature IDs. This assumes that a container of 3D feature positions is</span>
  <span class="c1">// owned elsewhere. This is essentially the track ID, and the main usage is</span>
  <span class="c1">// for reconstructions where many 2D points correspond to a single 3D point.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">feature_3D_ids_</span><span class="p">;</span>

  <span class="c1">// If the 3D positions are stored locally, then we can keep them in a</span>
  <span class="c1">// container here.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">&gt;</span> <span class="n">feature_positions_3D_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The pose of the camera is contained in the <a class="reference internal" href="#CameraPose" title="CameraPose"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CameraPose</span></tt></a> object. This
class contains extrinsic (rotation and translation) and intrinsic calibration
(focal length, principle point, radial distortion) information for the camera,
and provides many convenience functions for various image and point
transformations.</p>
<blockquote>
<div><dl class="class">
<dt id="CameraPose">
<em class="property">class </em><tt class="descname">CameraPose</tt><a class="headerlink" href="#CameraPose" title="Permalink to this definition">¶</a></dt>
<dd><dl class="function">
<dt id="CameraPose::CameraPose">
 <tt class="descname">CameraPose</tt><big>(</big><big>)</big><a class="headerlink" href="#CameraPose::CameraPose" title="Permalink to this definition">¶</a></dt>
<dd><p>The default constructor. Sets all values to identity values.</p>
</dd></dl>

<p>The <a class="reference internal" href="#CameraPose" title="CameraPose"><tt class="xref cpp cpp-class docutils literal"><span class="pre">CameraPose</span></tt></a> class must be initialized with the
<a class="reference internal" href="#CameraPose::InitializePose__Eigen::Matrix3dCR.Eigen::Vector3dCR.Eigen::Matrix3dCR.doubleC.doubleC.doubleC.doubleC" title="CameraPose::InitializePose"><tt class="xref cpp cpp-func docutils literal"><span class="pre">InitializePose()</span></tt></a> method rather than with the constructor. There are
several variations of this method so as to be flexible to the information
that the user has available:</p>
<dl class="function">
<dt id="CameraPose::InitializePose__Eigen::Matrix3dCR.Eigen::Vector3dCR.Eigen::Matrix3dCR.doubleC.doubleC.doubleC.doubleC">
void <tt class="descname">InitializePose</tt><big>(</big>const Eigen::Matrix3d&amp; <em>rotation</em>, const Eigen::Vector3d&amp; <em>translation</em>, const Eigen::Matrix3d&amp; <em>calibration</em>, const double <em>k1</em>, const double <em>k2</em>, const double <em>k3</em>, const double <em>k4</em><big>)</big><a class="headerlink" href="#CameraPose::InitializePose__Eigen::Matrix3dCR.Eigen::Vector3dCR.Eigen::Matrix3dCR.doubleC.doubleC.doubleC.doubleC" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the camera pose with the full extrinsic (rotation and
translation) and intrinsic (calibration matrix and radial distortion)
parameters. The extrinsic parameters should provide world-to-camera
transformations.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::InitializePose__Eigen::Matrix:double.3.4:CR.doubleC.doubleC.doubleC.doubleC">
void <tt class="descname">InitializePose</tt><big>(</big>const Eigen::Matrix&lt;double, 3, 4&gt;&amp; <em>projection_matrix</em>, const double <em>k1</em>, const double <em>k2</em>, const double <em>k3</em>, const double <em>k4</em><big>)</big><a class="headerlink" href="#CameraPose::InitializePose__Eigen::Matrix:double.3.4:CR.doubleC.doubleC.doubleC.doubleC" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the pose with a projection matrix given by P = K * [R | t],
where K is the calibration matrix, R is the rotation matrix, and t is the
translation. The projection matrix provided should be a world-to-image
transformation (as opposed to world-to-camera).</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::InitializePose__Eigen::Matrix:double.3.4:CR.Eigen::Matrix3dCR.doubleC.doubleC.doubleC.doubleC">
void <tt class="descname">InitializePose</tt><big>(</big>const Eigen::Matrix&lt;double, 3, 4&gt;&amp; <em>transformation_matrix</em>, const Eigen::Matrix3d&amp; <em>calibration</em>, const double <em>k1</em>, const double <em>k2</em>, const double <em>k3</em>, const double <em>k4</em><big>)</big><a class="headerlink" href="#CameraPose::InitializePose__Eigen::Matrix:double.3.4:CR.Eigen::Matrix3dCR.doubleC.doubleC.doubleC.doubleC" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the pose with a given transformation matrix that defines the
world-to-camera transformation.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::InitializePose__CameraPoseCR">
void <tt class="descname">InitializePose</tt><big>(</big>const CameraPose&amp; <em>pose</em><big>)</big><a class="headerlink" href="#CameraPose::InitializePose__CameraPoseCR" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy constructor.</p>
</dd></dl>

<p>It is important to be able to access components of the camera pose, so we
provide getter functions for all relative information:</p>
<dl class="function">
<dt id="CameraPose::rotation_matrixC">
Eigen::Matrix3d <tt class="descname">rotation_matrix</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::rotation_matrixC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rotation componenet of the transformation matrix.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::translationC">
Eigen::Vector3d <tt class="descname">translation</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::translationC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the translation componenet of the transformation matrix.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::positionC">
Eigen::Vector3d <tt class="descname">position</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::positionC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the camera position in the world coordinate system defined as
position = -R&#8217; * t.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::calibration_matrixC">
Eigen::Matrix3d <tt class="descname">calibration_matrix</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::calibration_matrixC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the 3x3 camera calibration matrix defined by K = diag(f, f, 1).</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::focal_lengthC">
double <tt class="descname">focal_length</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::focal_lengthC" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the focal length of the camera.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::radial_distortion__doubleP.doubleP.doubleP.doublePC">
void <tt class="descname">radial_distortion</tt><big>(</big>double* <em>k1</em>, double* <em>k2</em>, double* <em>k3</em>, double* <em>k4</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::radial_distortion__doubleP.doubleP.doubleP.doublePC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the radial distortion parameters.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::projection_matrixC">
Eigen::Matrix&lt;double, 3, 4&gt; <tt class="descname">projection_matrix</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::projection_matrixC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the full projection matrix that describes the camera pose.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::transformation_matrixC">
Eigen::Matrix&lt;double, 3, 4&gt; <tt class="descname">transformation_matrix</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::transformation_matrixC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transformation matrix <span class="math">\(T = [R | t]\)</span> i.e., the extrinsic parameters.</p>
</dd></dl>

<p>Finally, the most important functionality of a camera is that it projects
points in the world into the image. Modeling this projection is a crucial
part of structure from motion (and all projective geometry!), so we provide
transformation functions to perform these tasks for you. We define three
coordinate systems: the world coordinate system, camera coordinate system,
and image coordinate system. The world coordinate system is defined as the
3D coordinate system relative to some world origin. 3D points in SfM models
are typically defined with respect to the world coordinate system. The
camera coordinate system is the coordinate system centered around the
camera. That is, with the camera at the origin looking down the
z-axis. Finally, the image coordinate system is the camera coordinate system
projected onto the image plane. The image coordinate system is defined in
pixels, and may only be reconciled with respect to the other coordinate
systems when the intrinsic paramters are known.</p>
<p>So, given a point in the world coordinate system, <span class="math">\(X_w\)</span>, we can
transform that point with a translation and rotation <span class="math">\(T=[R | t]\)</span> such
that <span class="math">\(X_c = T * X_w\)</span> is a point in the camera coordinate system. To
transform <span class="math">\(X_c\)</span> into image coordinates, we must apply the camera
calibration matrix, <span class="math">\(K\)</span> such that <span class="math">\(X_i = K * T * X_w\)</span> is a point
in the image plane (in pixels).</p>
<p>The functions below provide these transformations for a single point, as
well as optimized transformations for transforming multiple points at the
same time.</p>
<dl class="function">
<dt id="CameraPose::WorldToCamera__Eigen::Vector3dCR.Eigen::Vector3dPC">
void <tt class="descname">WorldToCamera</tt><big>(</big>const Eigen::Vector3d&amp; <em>world_point</em>, Eigen::Vector3d* <em>camera_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::WorldToCamera__Eigen::Vector3dCR.Eigen::Vector3dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a point from the world coordinate system to the camera
coordinate system.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::WorldToCamera__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:PC">
void <tt class="descname">WorldToCamera</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>world_point</em>, std::vector&lt;Eigen::Vector3d&gt;* <em>camera_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::WorldToCamera__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation method for multiple points.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::CameraToWorld__Eigen::Vector3dCR.Eigen::Vector3dPC">
void <tt class="descname">CameraToWorld</tt><big>(</big>const Eigen::Vector3d&amp; <em>camera_point</em>, Eigen::Vector3d* <em>world_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::CameraToWorld__Eigen::Vector3dCR.Eigen::Vector3dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a point from the camera coordinate system to the world
coordinate system.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::CameraToWorld__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:PC">
void <tt class="descname">CameraToWorld</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>camera_point</em>, std::vector&lt;Eigen::Vector3d&gt;* <em>world_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::CameraToWorld__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation method for multiple points.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::CameraToImage__Eigen::Vector3dCR.Eigen::Vector2dPC">
void <tt class="descname">CameraToImage</tt><big>(</big>const Eigen::Vector3d&amp; <em>camera_point</em>, Eigen::Vector2d* <em>image_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::CameraToImage__Eigen::Vector3dCR.Eigen::Vector2dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the 3D points in camera coordinates into the image plane using the
calibration matrix of the camera.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::CameraToImage__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector2d:PC">
void <tt class="descname">CameraToImage</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>camera_point</em>, std::vector&lt;Eigen::Vector2d&gt;* <em>image_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::CameraToImage__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector2d:PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Projection method for multiple points. NOTE: this method is void, and does
not indicate whether points are in front of behind the camera.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::WorldToImage__Eigen::Vector3dCR.Eigen::Vector2dPC">
bool <tt class="descname">WorldToImage</tt><big>(</big>const Eigen::Vector3d&amp; <em>world_point</em>, Eigen::Vector2d* <em>image_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::WorldToImage__Eigen::Vector3dCR.Eigen::Vector2dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Projects the 3D points in world coordinates into the image plane using the
projection matrix of the camera. Returns true if the point is in front of
the camera and false otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::WorldToImage__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector2d:PC">
void <tt class="descname">WorldToImage</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>world_point</em>, std::vector&lt;Eigen::Vector2d&gt;* <em>image_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::WorldToImage__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector2d:PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Projection method for multiple points. NOTE: this method is void, and does
not indicate whether points are in front of behind the camera.</p>
</dd></dl>

<p>Correcting radial distortion can be a common operation for SfM so that the
images may be as geomtetrically correct as possible. The following two
functions will undistort image points based on the intrinsic paramters of
the camera.</p>
<dl class="function">
<dt id="CameraPose::UndistortImagePoint__Eigen::Vector2dCR.Eigen::Vector2dPC">
void <tt class="descname">UndistortImagePoint</tt><big>(</big>const Eigen::Vector2d&amp; <em>distorted_point</em>, Eigen::Vector2d* <em>undistorted_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::UndistortImagePoint__Eigen::Vector2dCR.Eigen::Vector2dPC" title="Permalink to this definition">¶</a></dt>
<dd><p>Undistorts the image point using the radial distortion parameters.</p>
</dd></dl>

<dl class="function">
<dt id="CameraPose::UndistortImagePoint__std::vector:Eigen::Vector2d:CR.std::vector:Eigen::Vector2d:PC">
void <tt class="descname">UndistortImagePoint</tt><big>(</big>const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>distorted_point</em>, std::vector&lt;Eigen::Vector2d&gt;* <em>undistorted_point</em><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#CameraPose::UndistortImagePoint__std::vector:Eigen::Vector2d:CR.std::vector:Eigen::Vector2d:PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Undistort multiple points at the same time.</p>
</dd></dl>

</dd></dl>

</div></blockquote>
</div>
<div class="section" id="view-triangulation">
<h2>2-View Triangulation<a class="headerlink" href="#view-triangulation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Triangulation in structure from motion calculates the 3D position of an image
coordinate that has been tracked through several, if not many, images.</p>
<dl class="function">
<dt id="Triangulate__ProjectionMatrixCR.ProjectionMatrixCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector3dP">
bool <tt class="descname">Triangulate</tt><big>(</big>const ProjectionMatrix&amp; <em>pose_left</em>, const ProjectionMatrix&amp; <em>pose_right</em>, const Eigen::Vector2d&amp; <em>point_left</em>, const Eigen::Vector2d&amp; <em>point_right</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#Triangulate__ProjectionMatrixCR.ProjectionMatrixCR.Eigen::Vector2dCR.Eigen::Vector2dCR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd><p>2-view triangulation using the DLT method described in
<a class="reference internal" href="bibliography.html#hartleyzisserman">[HartleyZisserman]</a>. The poses are the (potentially calibrated) poses of the
two cameras, and the points are the 2D image points of the matched features
that will be used to triangulate the 3D point. If there was an error computing
the triangulation (e.g., the point is found to be at infinity) then <tt class="docutils literal"><span class="pre">false</span></tt>
is returned. On successful triangulation, <tt class="docutils literal"><span class="pre">true</span></tt> is returned.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="n-view-triangulation">
<h2>N-View Triangulation<a class="headerlink" href="#n-view-triangulation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="TriangulateNViewSVD__std::vector:ProjectionMatrix:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNViewSVD</tt><big>(</big>const std::vector&lt;ProjectionMatrix&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNViewSVD__std::vector:ProjectionMatrix:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TriangulateNView__std::vector:ProjectionMatrix:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP">
bool <tt class="descname">TriangulateNView</tt><big>(</big>const std::vector&lt;ProjectionMatrix&gt;&amp; <em>poses</em>, const std::vector&lt;Eigen::Vector2d&gt;&amp; <em>points</em>, Eigen::Vector3d* <em>triangulated_point</em><big>)</big><a class="headerlink" href="#TriangulateNView__std::vector:ProjectionMatrix:CR.std::vector:Eigen::Vector2d:CR.Eigen::Vector3dP" title="Permalink to this definition">¶</a></dt>
<dd><p>We provide two N-view triangluation methods that minimizes an algebraic
approximation of the geometric error. The first is the classic SVD method
presented in <a class="reference internal" href="bibliography.html#hartleyzisserman">[HartleyZisserman]</a>. The second is a custom algebraic
minimization. Note that we can derive an algebraic constraint where we note
that the unit ray of an image observation can be stretched by depth
<span class="math">\(\alpha\)</span> to meet the world point <span class="math">\(X\)</span> for each of the <span class="math">\(n\)</span>
observations:</p>
<div class="math">
\[\alpha_i \bar{x_i} = P_i X,\]</div>
<p>for images <span class="math">\(i=1,\ldots,n\)</span>. This equation can be effectively rewritten as:</p>
<div class="math">
\[\alpha_i = \bar{x_i}^\top P_i X,\]</div>
<p>which can be substituted into our original constraint such that:</p>
<div class="math">
\[\bar{x_i} \bar{x_i}^\top P_i X = P_i X\]</div>
<div class="math">
\[0 = (P_i - \bar{x_i} \bar{x_i}^\top P_i) X\]</div>
<p>We can then stack this constraint for each observation, leading to the linear
least squares problem:</p>
<div class="math">
\[\begin{split}\begin{bmatrix} (P_1 - \bar{x_1} \bar{x_1}^\top P_1) \\ \vdots \\ (P_n - \bar{x_n} \bar{x_n}^\top P_n) \end{bmatrix} X = \textbf{0}\end{split}\]</div>
<p>This system of equations is of the form <span class="math">\(AX=0\)</span> which can be solved by
extracting the right nullspace of <span class="math">\(A\)</span>. The right nullspace of <span class="math">\(A\)</span>
can be extracted efficiently by noting that it is equivalent to the nullspace
of <span class="math">\(A^\top A\)</span>, which is a 4x4 matrix.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="similarity-transformation">
<h2>Similarity Transformation<a class="headerlink" href="#similarity-transformation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="function">
<dt id="AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA">
void <tt class="descname">AlignPointCloudsICP</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3]<big>)</big><a class="headerlink" href="#AlignPointCloudsICP__iC.doubleCA.doubleCA.doubleA.doubleA" title="Permalink to this definition">¶</a></dt>
<dd><p>We implement ICP for point clouds. We use Besl-McKay registration to align
point clouds. We use SVD decomposition to find the rotation, as this is much
more likely to find the global minimum as compared to traditional ICP, which
is only guaranteed to find a local minimum. Our goal is to find the
transformation from the left to the right coordinate system. We assume that
the left and right models have the same number of points, and that the
points are aligned by correspondence (i.e. left[i] corresponds to right[i]).</p>
</dd></dl>

<dl class="function">
<dt id="AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP">
void <tt class="descname">AlignPointCloudsUmeyama</tt><big>(</big>const int <em>num_points</em>, const double <em>left</em>[], const double <em>right</em>[], double <em>rotation</em>[3 * 3], double <em>translation</em>[3], double* <em>scale</em><big>)</big><a class="headerlink" href="#AlignPointCloudsUmeyama__iC.doubleCA.doubleCA.doubleA.doubleA.doubleP" title="Permalink to this definition">¶</a></dt>
<dd><p>This function estimates the 3D similiarty transformation using the least
squares method of <a class="reference internal" href="bibliography.html#umeyama">[Umeyama]</a>. The returned rotation, translation, and scale
align the left points to the right such that <span class="math">\(Right = s * R * Left +
t\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="DlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P">
void <tt class="descname">DlsSimilarityTransform</tt><big>(</big>const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_origin</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>ray_direction</em>, const std::vector&lt;Eigen::Vector3d&gt;&amp; <em>world_point</em>, std::vector&lt;Eigen::Quaterniond&gt;* <em>solution_rotation</em>, std::vector&lt;Eigen::Vector3d&gt;* <em>solution_translation</em>, std::vector&lt;double&gt;* <em>solution_scale</em><big>)</big><a class="headerlink" href="#DlsSimilarityTransform__std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Vector3d:CR.std::vector:Eigen::Quaterniond:P.std::vector:Eigen::Vector3d:P.std::vector:double:P" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the solution to the generalized pose and scale problem based on the
paper &#8220;gDLS: A Scalable Solution to the Generalized Pose and Scale Problem&#8221;
by Sweeney et. al. <a class="reference internal" href="bibliography.html#sweeneygdls">[SweeneyGDLS]</a>. Given image rays from one coordinate
system that correspond to 3D points in another coordinate system, this
function computes the rotation, translation, and scale that will align the
rays with the 3D points. This is used for applications such as loop closure
in SLAM and SfM. This method is extremely scalable and highly accurate
because the cost function that is minimized is independent of the number of
points. Theoretically, up to 27 solutions may be returned, but in practice
only 4 real solutions arise and in almost all cases where n &gt;= 6 there is
only one solution which places the observed points in front of the
camera. The rotation, translation, and scale are defined such that:
<span class="math">\(sp_i + \alpha_i d_i = RX_i + t\)</span> where the observed image ray has an
origin at <span class="math">\(p_i\)</span> in the unit direction <span class="math">\(d_i\)</span> corresponding to 3D
point <span class="math">\(X_i\)</span>.</p>
<p><tt class="docutils literal"><span class="pre">ray_origin</span></tt>: the origin (i.e., camera center) of the image ray used in
the 2D-3D correspondence.</p>
<p><tt class="docutils literal"><span class="pre">ray_direction</span></tt>: Normalized image rays corresponding to model points. Must
contain at least 4 points.</p>
<p><tt class="docutils literal"><span class="pre">world_point</span></tt>: 3D location of features. Must correspond to the image_ray
of the same index. Must contain the same number of points as image_ray, and
at least 4.</p>
<p><tt class="docutils literal"><span class="pre">solution_rotation</span></tt>: the rotation quaternion of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_translation</span></tt>: the translation of the candidate solutions</p>
<p><tt class="docutils literal"><span class="pre">solution_scale</span></tt>: the scale of the candidate solutions</p>
</dd></dl>

</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/theia_logo.png" alt="Logo"/>
            </a></p>

<h3><a href="index.html">Theia</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building.html">Building Theia Library</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image.html">Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2"><a class="reference internal" href="ransac.html">Ransac</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html">Pose and Resectioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html">Math</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Structure from Motion (SfM)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributions.html">Contributing to Theia</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="math.html"
                        title="previous chapter">Math</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tutorials.html"
                        title="next chapter">Tutorials</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorials.html" title="Tutorials"
             >next</a> |</li>
        <li class="right" >
          <a href="math.html" title="Math"
             >previous</a> |</li>
        <li><a href="index.html">Theia Documentation</a> &raquo;</li>
          <li><a href="documentation.html" >Documentation</a> &raquo;</li> 
      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2014, Chris Sweeney.
</div>


  </body>
</html>