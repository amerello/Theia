
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    

    <title>Ransac &mdash; Theia Documentation</title>

<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>

<!-- Google Analytics Code -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46196711-1', 'ucsb.edu');
  ga('send', 'pageview');

</script>


    
    <link rel="stylesheet" href="_static/rtd.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
  MathJax.Hub.Config({
    "HTML-CSS": {
      availableFonts: ["TeX"]
    }
  });
</script>
    <script type="text/javascript" src="_static/searchtools.js"></script>
    <link rel="top" title="Theia Documentation" href="index.html" />
    <link rel="up" title="Documentation" href="documentation.html" />
    <link rel="next" title="Pose and Resectioning" href="pose.html" />
    <link rel="prev" title="Features" href="features.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pose.html" title="Pose and Resectioning"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="features.html" title="Features"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Theia Documentation</a> &raquo;</li>
          <li><a href="documentation.html" accesskey="U">Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ransac">
<span id="documentation-ransac"></span><h1>Ransac<a class="headerlink" href="#ransac" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC">Random Sample Consensus</a>, or RANSAC, one
of the most commonly used algorithms in Computer Vision. As a result, much
research has gone into making RANSAC extensions and variants that increase the
efficiency or accuracy of the estimation. We have implemented a templated class
that makes using RANSAC for estimation extremely easy as well as simple to
extend.</p>
<p>This module can be included in your code with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;theia/ransac.h&gt;</span>
</pre></div>
</div>
<p><strong>NOTE</strong>: For the descriptions below, we often use the term &#8220;RANSAC&#8221; to mean the general strategy of model estimation via sample consensus. Most of the time, &#8220;RANSAC&#8221; refers to RANSAC and the variants we have implemented.</p>
<p>The following RANSAC methods are implemented in Theia:</p>
<ul class="simple">
<li><a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a></li>
<li><a class="reference internal" href="#Prosac" title="Prosac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Prosac</span></tt></a></li>
<li><a class="reference internal" href="#Mlesac" title="Mlesac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Mlesac</span></tt></a></li>
<li><a class="reference internal" href="#Arrsac" title="Arrsac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Arrsac</span></tt></a></li>
<li><tt class="xref cpp cpp-class docutils literal"><span class="pre">Recon</span></tt></li>
</ul>
<div class="section" id="estimator">
<h2><a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a><a class="headerlink" href="#estimator" title="Permalink to this headline">¶</a></h2>
<p>The basic method for using RANSAC (and its variants) is to specify the class
corresponding to the algorithm you will use (e.g. RANSAC, PROSAC, etc.) and the
method for estimating a model from data points. The interface to do the latter
requires you implement derived class of the <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a> class.</p>
<dl class="class">
<dt id="Estimator">
<em class="property">class </em><tt class="descname">Estimator</tt><a class="headerlink" href="#Estimator" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Datum</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Model</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Estimator</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Estimator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Estimator</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">double</span> <span class="n">SampleSize</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EstimateModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">double</span> <span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="n">Datum</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Functions to optionally implement.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EstimateModelNonminimal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&gt;*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">RefineModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="n">Model</span><span class="o">*</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ValidModel</span><span class="p">(</span><span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// Helper methods implemented in base class.</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Residuals</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">GetInliers</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span>
                               <span class="kt">double</span> <span class="n">error_threshold</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">GetNumInliers</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">Model</span><span class="o">&amp;</span> <span class="n">model</span><span class="p">,</span>
                    <span class="kt">double</span> <span class="n">error_threshold</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The only methods that are required to be implemented are the
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::EstimateModel()</span></tt>, <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::SampleSize()</span></tt>, and
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimator::Error()</span></tt> methods. These methods specify how the model is
estimated from the data provided, and how the error residuals are
calculated from a given model. All other methods are optional to
implement, but will only enhance the output of RANSAC.</p>
</dd></dl>

</div>
<div class="section" id="using-the-ransac-classes">
<h2>Using the RANSAC classes<a class="headerlink" href="#using-the-ransac-classes" title="Permalink to this headline">¶</a></h2>
<p>In order to make our RANSAC classes consistent and extendible we specify an
interface as a <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class. All of the RANSAC
variants in Theia are derived from this class, so they are all guaranteed to
have the same interface. When using a RANSAC (or RANSAC-variant) class, you
simply need to create a ransac object, set up the parameters you want to use,
and then call the <a class="reference internal" href="#SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP" title="SampleConsensusEstimator::Estimate"><tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate</span></tt></a> method.</p>
<dl class="function">
<dt id="SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP">
bool <tt class="descclassname">SampleConsensusEstimator::</tt><tt class="descname">Estimate</tt><big>(</big>const std::vector&lt;Datum&gt;&amp; <em>data</em>, Model* <em>best_model</em>, RansacSummary* <em>summary</em><big>)</big><a class="headerlink" href="#SampleConsensusEstimator::Estimate__std::vector:Datum:CR.ModelP.RansacSummaryP" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main (and often the only) method you use when performing RANSAC
(or a variant). It computes a model given the data and the <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a>
class that you have specified for your problem. It returns true (and sets the
<tt class="docutils literal"><span class="pre">best_model</span></tt> parameter) upon success, and false (with <tt class="docutils literal"><span class="pre">best_model</span></tt> having
undefined behavior) upon failure.</p>
</dd></dl>

<p>The other main component of using one of the RANSAC methods is to set up the
<a class="reference internal" href="#RansacParameters" title="RansacParameters"><tt class="xref cpp cpp-class docutils literal"><span class="pre">RansacParameters</span></tt></a> used for the RANSAC scheme. <a class="reference internal" href="#RansacParameters" title="RansacParameters"><tt class="xref cpp cpp-class docutils literal"><span class="pre">RansacParameters</span></tt></a>
is a struct that holds several crucial elements to deciding how the RANSAC
scheme performs.</p>
<dl class="class">
<dt id="RansacParameters">
<em class="property">class </em><tt class="descname">RansacParameters</tt><a class="headerlink" href="#RansacParameters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">error_thresh</span></tt>: Error threshold to determin inliers for RANSAC (e.g.,</dt>
<dd>squared reprojection error). This is what will be used by the estimator to
determine inliers.</dd>
<dt><tt class="docutils literal"><span class="pre">failure_probability</span></tt>: The failure probability of RANSAC. Set to 0.01 means</dt>
<dd>that RANSAC has a 1% chance of missing the correct pose. The default value is
0.01</dd>
<dt><tt class="docutils literal"><span class="pre">min_inlier_ratio</span></tt>: The minimal assumed inlier ratio, i.e., it is assumed</dt>
<dd>that the given set of correspondences has an inlier ratio of at least
min_inlier_ratio. This is required to limit the number of RANSAC
iteratios. The default ratio is 0.1</dd>
<dt><tt class="docutils literal"><span class="pre">max_iterations</span></tt>: Another way to specify the maximal number of RANSAC</dt>
<dd>iterations. In effect, the maximal number of iterations is set to
min(max_ransac_iterations, T), where T is the number of iterations
corresponding to min_inlier_ratio.  This variable is useful if RANSAC is
to be applied iteratively, i.e., first applying RANSAC with an
min_inlier_ratio of x, then with one of x-y and so on, and we want to
avoid repeating RANSAC iterations.  However, the preferable way to limit
the number of RANSAC iterations is to set min_inlier_ratio and leave
max_ransac_iterations to its default value.  Per default, this variable is
set to std::numeric_limits&lt;int&gt;::max().</dd>
<dt><tt class="docutils literal"><span class="pre">use_Tdd_test</span></tt>: Whether to use the T_{d,d}, with d=1, test proposed in <a class="reference internal" href="bibliography.html#chumrandomizedransac">[ChumRandomizedRansac]</a></dt>
<dd>After computing the model, RANSAC selects one match at random and evaluates all
poses. If the point is an outlier to one pose, the corresponding pose is
rejected. Notice that if the pose solver returns multiple poses, then at
most one pose is correct. If the selected match is correct, then only the
correct pose will pass the test. Per default, the test is disabled.
NOTE: Not currently implemented!</dd>
</dl>
</dd></dl>

<p>We will illustrate the use of the RANSAC class with a simple line estimation example.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Our &quot;data&quot;.</span>
<span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Our &quot;model&quot;.</span>
<span class="k">struct</span> <span class="n">Line</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">m</span><span class="p">;</span> <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Estimator class.</span>
<span class="k">class</span> <span class="nc">LineEstimator</span><span class="o">:</span> <span class="k">public</span> <span class="n">Estimator</span><span class="o">&lt;</span><span class="n">Point</span><span class="p">,</span> <span class="n">Line</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// Number of points needed to estimate a line.</span>
  <span class="kt">double</span> <span class="n">SampleSize</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Estimate a line from two points.</span>
  <span class="kt">bool</span> <span class="n">EstimateModel</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Line</span><span class="o">&gt;*</span> <span class="n">models</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Line</span> <span class="n">model</span><span class="p">;</span>
    <span class="n">model</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">);</span>
    <span class="n">model</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">model</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
    <span class="n">models</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Calculate the error as the y distance of the point to the line.</span>
  <span class="kt">double</span> <span class="n">Error</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">,</span> <span class="k">const</span> <span class="n">Line</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">m</span><span class="o">*</span><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">line</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>Specifying an <a class="reference internal" href="#Estimator" title="Estimator"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Estimator</span></tt></a> is that easy! Now lets look at how to actually
use a RANSAC method to use the <tt class="xref cpp cpp-class docutils literal"><span class="pre">LineEstimator</span></tt>.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Generate your input data using your desired method.</span>
  <span class="c1">// We put pseudo-code here for simplicity.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">input_data</span><span class="p">;</span>

  <span class="c1">// Add 700 inliers.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">700</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">inlier_point</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Add 300 outliers.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">outlier_point</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Specify RANSAC parameters.</span>
  <span class="kt">double</span> <span class="n">error_threshold</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">min_num_inliers</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

  <span class="c1">// Estimate the line with RANSAC.</span>
  <span class="n">LineEstimator</span> <span class="n">line_estimator</span><span class="p">;</span>
  <span class="n">Line</span> <span class="n">best_line</span><span class="p">;</span>
  <span class="c1">// Set the ransac parameters.</span>
  <span class="n">RansacParameters</span> <span class="n">params</span><span class="p">;</span>
  <span class="n">params</span><span class="p">.</span><span class="n">error_thresh</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>

  <span class="c1">// Create Ransac object, specifying the number of points to sample to</span>
  <span class="c1">// generate a model estimation.</span>
  <span class="n">Ransac</span><span class="o">&lt;</span><span class="n">LineEstimator</span><span class="o">&gt;</span> <span class="n">ransac_estimator</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">line_estimator</span><span class="p">);</span>
  <span class="c1">// Initialize must always be called!</span>
  <span class="n">ransac_estimator</span><span class="p">.</span><span class="n">Initialize</span><span class="p">();</span>

  <span class="n">RansacSummary</span> <span class="n">summary</span><span class="p">;</span>
  <span class="n">ransac_estimator</span><span class="p">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">best_line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Line m = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">best_line</span><span class="p">.</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*x + &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">best_line</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>There you have it. With just a few lines of code we can use RANSAC to estimate
the best fitting line. You could easily swap the <a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class with any
of the RANSAC variants implemented in Theia without having to change anything
else in the code.</p>
</div>
<div class="section" id="instances-of-ransac-methods">
<span id="section-constructors"></span><h2>Instances of RANSAC Methods<a class="headerlink" href="#instances-of-ransac-methods" title="Permalink to this headline">¶</a></h2>
<p>Theia has implemented several RANSAC methods as derived classes of the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class. The typical use case is still to call
the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method, but each method is likely to have a different
constructor. The constructors for each method are specified as follows</p>
<dl class="class">
<dt id="Ransac">
<em class="property">class </em><tt class="descname">Ransac</tt><a class="headerlink" href="#Ransac" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard <a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC">RANSAC</a> implementation as originally proposed by Fischler et. al. <a class="reference internal" href="bibliography.html#fischler">[Fischler]</a></p>
<dl class="function">
<dt id="Ransac::Ransac__RansacParamsCR.EstimatorCR">
 <tt class="descname">Ransac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em><big>)</big><a class="headerlink" href="#Ransac::Ransac__RansacParamsCR.EstimatorCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Prosac">
<em class="property">class </em><tt class="descname">Prosac</tt><a class="headerlink" href="#Prosac" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Progressive Sampling Consensus as originally proposed by <a class="reference internal" href="bibliography.html#chum">[Chum]</a>. Input data
is assumed to have a quality to it, which can then be exposed in your
sampling strategy by smartly sampling the high quality data points first,
then progressively sampling the rest of the data set. In the worst case, this
algorithm degenerates to RANSAC, but typically is significantly faster.</div></blockquote>
<dl class="function">
<dt id="Prosac::Prosac__RansacParamsCR.EstimatorCR">
 <tt class="descname">Prosac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em><big>)</big><a class="headerlink" href="#Prosac::Prosac__RansacParamsCR.EstimatorCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="docutils">
<dt><strong>NOTE:</strong> the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method for prosace assumes the data is sorted</dt>
<dd>by quality! That is, that the highest quality data point is first, and the
worst quality data point is last in the input vector.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="Mlesac">
<em class="property">class </em><tt class="descname">Mlesac</tt><a class="headerlink" href="#Mlesac" title="Permalink to this definition">¶</a></dt>
<dd><p>A generalization of RANSAC that chooses to maximize the likelihood of an estimation rather than the inlier count. Proposed by <a class="reference internal" href="bibliography.html#torr">[Torr]</a> et. al.</p>
<dl class="function">
<dt id="Mlesac::Mlesac__RansacParamsCR.EstimatorCR">
 <tt class="descname">Mlesac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em><big>)</big><a class="headerlink" href="#Mlesac::Mlesac__RansacParamsCR.EstimatorCR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="Arrsac">
<em class="property">class </em><tt class="descname">Arrsac</tt><a class="headerlink" href="#Arrsac" title="Permalink to this definition">¶</a></dt>
<dd><p>Adaptive Real-Time Consensus is a method proposed by <a class="reference internal" href="bibliography.html#raguram">[Raguram]</a> that utilizes
pre-emptive techniques to perform a partially depth-first evaluation of many
generated hypotheses at once. This allows for a bounded running time while
pursuing only the models which are most likely to lead to high quality
results. This results in a very fast method which can be used for real-time applications.</p>
<dl class="function">
<dt id="Arrsac::Arrsac__RansacParamsCR.EstimatorCR.i.i">
 <tt class="descname">Arrsac</tt><big>(</big>const RansacParams&amp; <em>params</em>, const Estimator&amp; <em>estimator</em>, int <em>max_candidate_hyps</em><em>=500</em>, int <em>block_size</em><em>=100</em><big>)</big><a class="headerlink" href="#Arrsac::Arrsac__RansacParamsCR.EstimatorCR.i.i" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">max_candidate_hyps</span></tt>: Maximum number of hypotheses in the initial hypothesis set</p>
<p><tt class="docutils literal"><span class="pre">block_size</span></tt>: Number of data points a hypothesis is evaluated against before preemptive ordering is used.</p>
</dd></dl>

<p><strong>NOTE</strong>: This method works for all the unit tests currently in Theia, but needs to be tested further to ensure correctness. Use with caution.</p>
</dd></dl>

</div>
<div class="section" id="implementing-a-new-ransac-method">
<h2>Implementing a New RANSAC Method<a class="headerlink" href="#implementing-a-new-ransac-method" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt> class consists of two main items: a
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and a <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt>. These two members specify
the most important aspects of most RANSAC techniques: how the data is sampled
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt>) and how the model quality (or, conversely, error) is measured
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt>). Adjusting the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> is how techniques
such as PROSAC achieve success. Adjusting the measurement of model quality from
the trivial method (e.g. counting inliers) is how methods such as MLESAC achieve
good results. Both the <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> classes
are pure virtual classes that must be derived for all RANSAC methods. Further,
the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method implemented in the <tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>
base class performs a typical RANSAC style routine, sampling according to the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> specified.</p>
<p>To implement a new RANSAC method, you should create a class derived from
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>. Most methods will probably involve simply
using a new sampler or quality measurement class, as the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt>
function will not change and can simply be inherited from the
<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensus</span></tt> class. In those cases, you can follow the model of the
<a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class to specify your new RANSAC-variant class:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// NOTE: ModelEstimator must be a subclass of the Estimator class.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">ModelEstimator</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Ransac</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ModelEstimator</span><span class="o">::</span><span class="n">Datum</span> <span class="n">Datum</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">ModelEstimator</span><span class="o">::</span><span class="n">Model</span> <span class="n">Model</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="nf">Ransac</span><span class="p">(</span><span class="k">const</span> <span class="n">RansacParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span> <span class="k">const</span> <span class="n">ModelEstimator</span><span class="o">&amp;</span> <span class="n">estimator</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">estimator</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Ransac</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Initializes the random sampler and inlier support measurement.</span>
  <span class="kt">bool</span> <span class="n">Initialize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Sampler</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;*</span> <span class="n">random_sampler</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">RandomSampler</span><span class="o">&lt;</span><span class="n">Datum</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">estimator_</span><span class="p">.</span><span class="n">SampleSize</span><span class="p">());</span>
    <span class="n">QualityMeasurement</span><span class="o">*</span> <span class="n">inlier_support</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">InlierSupport</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">ransac_params_</span><span class="p">.</span><span class="n">error_thresh</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">SampleConsensusEstimator</span><span class="o">&lt;</span><span class="n">ModelEstimator</span><span class="o">&gt;::</span><span class="n">Initialize</span><span class="p">(</span>
        <span class="n">random_sampler</span><span class="p">,</span> <span class="n">inlier_support</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<p>This is all that the <a class="reference internal" href="#Ransac" title="Ransac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Ransac</span></tt></a> class needs to specify, and the
<tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> function implemented in the base class
(<tt class="xref cpp cpp-class docutils literal"><span class="pre">SampleConsensusEstimator</span></tt>) will use the <tt class="xref cpp cpp-class docutils literal"><span class="pre">RandomSampler</span></tt> to
randomly sample the data, and <tt class="xref cpp cpp-class docutils literal"><span class="pre">InlierSupport</span></tt> to calculate inliers. Of
course, <tt class="xref cpp cpp-class docutils literal"><span class="pre">RandomSampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">InliersSupport</span></tt> are derived classes
of <tt class="xref cpp cpp-class docutils literal"><span class="pre">Sampler</span></tt> and <tt class="xref cpp cpp-class docutils literal"><span class="pre">QualityMeasurement</span></tt> respectively. See the code
for more details.</p>
<p>If you want to create a new RANSAC method that involves changing the way
estimation happens, your class can override the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method. For our
implementation, <a class="reference internal" href="#Arrsac" title="Arrsac"><tt class="xref cpp cpp-class docutils literal"><span class="pre">Arrsac</span></tt></a> does this. See the code for those classes for a
good example on how you should override the <tt class="xref cpp cpp-func docutils literal"><span class="pre">Estimate()</span></tt> method.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/theia_logo.png" alt="Logo"/>
            </a></p>

<h3><a href="index.html">Theia</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building.html">Building Theia Library</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="image.html">Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Ransac</a></li>
<li class="toctree-l2"><a class="reference internal" href="pose.html">Pose and Resectioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="math.html">Math</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfm.html">Structure from Motion (SfM)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributions.html">Contributing to Theia</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="features.html"
                        title="previous chapter">Features</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pose.html"
                        title="next chapter">Pose and Resectioning</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pose.html" title="Pose and Resectioning"
             >next</a> |</li>
        <li class="right" >
          <a href="features.html" title="Features"
             >previous</a> |</li>
        <li><a href="index.html">Theia Documentation</a> &raquo;</li>
          <li><a href="documentation.html" >Documentation</a> &raquo;</li> 
      </ul>
    </div>
<div class="footer">
    &copy; Copyright 2014, Chris Sweeney.
</div>


  </body>
</html>